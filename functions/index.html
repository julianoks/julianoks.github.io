<link rel="stylesheet" type="text/css" href="../util/main.css">
<style type="text/css">
img {
	width: 150px;
}
img[alt="tuba"] {
	height: 150px;
	width: auto;
}
img[alt="mixture"] {
	height: auto;
	width: 350px;
}
</style>
<script src='../util/main.js'></script>
<body>
<markdown>
<center>
# Functions, tubas, and mixture models
</center>
------

## Relations, Functions
A relation is a pairing between sets. 
<center>

|   X   | &nbsp;&nbsp;&nbsp;&nbsp; |   Y   |
|:------|:-----:|--------:|
| 1 || -2 |
| 2 || 5 |
| 3 || 13 |
| 4 || 13 |
| 5 || 15 |

<span style="font-size: 8pt;">Example: a relation represented as a table.</span>
</center>

A function is a type of relation where every element in one set (the domain) is mapped to exactly one element in another (the range).
There are a few special types of functions: 
- *injective*, or one-to-one, functions map every X to a unique Y. The X and Y columns don't repeat.
- *surjective*, or onto, functions map every Y from some X. Every X and Y appear in the table (though Y's may repeat).
- *bijective* functions are injective and surjective, ie every X is mapped to a unique Y, and every Y corresonds to a unique X. Every X and Y appears in the table, and the X and Y columns don't repeat.

<center>

|   Plain Function   |   Injective Function   |   Surjective Function   |   Bijective Function   |
|:------|:-------:|--------:|--------:|
| ![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Not-Injection-Surjection.svg/360px-Not-Injection-Surjection.svg.png)   | ![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Injection.svg/360px-Injection.svg.png)  | ![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Surjection.svg/360px-Surjection.svg.png) | ![](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Bijection.svg/360px-Bijection.svg.png) |

</center>

### The inverses
An inverse reverses or "undoes" a function f: X→Y. 

With respect to f, a function:
- a: Y→X is a **left inverse** if a(f(x)) = x, ∀x.
- b: Y→X is a **right inverse** if f(b(y)) = y, ∀y.

In other words, the compositions (a∘f) and (f∘b) are the identity function.


#### Injective functions have a left inverse
Because each x∈X is associated with a distinct y∈Y, we can go back to x from y.
Given y, pick the only x that's associated with y.

However if the function is injective but not surjective, the left inverse will be a partial function because the range of the function, and thus domain of the inverse, will be a subset of Y.

#### Surjective functions have a right inverse
Because every y∈Y is associated with some x∈X, we can go to any y from some x.
Given y, pick an x that's associated with y.


#### Bijective functions have a unique left and right inverse
Because bijections are injective and surjective, they have both a left and a right inverse.
A function that has both a left and right inverse has one unique inverse.
Let a and b be any left and right inverses:
<center>
b = identity∘b = a∘f∘b = a∘identity = a
</center>
A few other properties:
- The inverse of a bijection is a bijection
- Composition of bijections is a bijection
- There can only be a bijection between two finite sets if they are the same size
- A bijection of a space could be presented as a different representation of the same space - one can always switch back and forth.

#### Bijections are cool
Bijections are cool because you can draw a bijection from one space to a more convenient one, and any assertions or constructions made in one space can be brought back to the other.
You've probably done this with word problems, where you transform a real-world problem to (and from) a "parallel" representation.

Ideally this parallel representation is easier to understand, visualize, or manipulate.
For example, you can convert a block-stacking problem into an addition problem, and vice-versa.
Or you can draw a bijection between numbers and binary representations, which can be plugged into a machine.

More examples of bijections:
- Change of coordinates
- Rotations
- Permutations
- Identity function
- Mapping from (0,1)→ℝ, eg <a href="http://www.wolframalpha.com/input/?i=ln(1%2Fx+-+1)">ln(1/x - 1)</a>
- Mapping from a line to a circle

------

## Talking through a tuba
<center>
	![tuba](https://music.psu.edu/sites/music.psu.edu/files/TubaEuph.jpg)
</center>
Could a tuba be a function? Sure, you put in a sound, another sound comes out. 
Lets say you speak plain english into a tuba.

If each input sound produces a distinct tuba sound, it's injective, so its left-invertible and you can reconstruct speach from the tuba.
The pipeline would be: 
<center>
speach → tuba → left-inverse → speach.
</center>

If a tuba could make any sound, your tuba would be surjective. 
You could find a right-inverse that could make a tuba say anything. 
The pipeline would be:
<center>
speach → right-inverse → tuba → speach.
</center>

Although I've never touched a tuba, they seem plausibly injective. A tuba left-inverse would be a fun project, and if someone gives me tuba input-output pairs, we could try to fit a left-inverse using something like a neural network.

I don't think tubas are surjective, because they seem to only be capable of making fart sounds.
But again, if you were to give me the data, I'd give it a shot!

------

## Relations that are not functions
If a relation has an input paired with multiple outputs, it is not a "true" function.

For example, this relation is not a function:
<center>
	![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Multivalued_function.svg/400px-Multivalued_function.svg.png)
</center>
Now what if we relate each input to a single set containing multiple outputs? This relation is a special kind of function known as a multivalued funciton.
Applying this to the above example, we could draw a relation between elements in X and *sets* of elements in Y:
<center>

|   X   | &nbsp;&nbsp;&nbsp;&nbsp; |   Y   |
|:------|:-----:|--------:|
| 1 || {a} |
| 2 || {d} |
| 3 || {b, c} |

</center>

The inverse of a non-injective function (eg the inverse of cos, arccos) can now be represented as a multivalued function.

### Mixture models
One way to represent a multivalued function is a function that maps from an element to a set, eg it may output {d} for some inputs and {b, c} for others. 
A more general approach is to define the multivalued function as a probability distribution over the range. 
This can be done using either a PMF (for discrete sets) or a PDF (for continuous sets).
We can represent our probability density using something called a "mixture model", a convex combination of components (such as gaussians). 

<center>
![mixture](https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/7055/versions/3/screenshot.JPG)

<span style="font-size: 8pt;">Example: (gaussian) mixture model</span>
</center>

A mixture model is similar to a kernel density estimate, but with far fewer components, and each component is weighted by a probability.
To make the PDF we can use a function approximator, like a neural network, that directly ouputs parameters to a mixture model (see mixture density networks).

Using a neural network as a multivalued function is exceptionally helpful for problems where many outputs should be associated with a single input; when there are many right answers.

Consider a confused bot that tries to caption images.
The dataset it's learning is multilingual; the desired caption could be spanish, english, etc.
Unfortunately, our bot doesn't know the language it should respond in. 
Doing it's best, our poor bot responds in a jumble of all the languages.
If our bot gave a mixture model, it would able to give n distinct responses, and even give its confidence in each response.

</markdown>

</body>